pub mod error;
pub mod params;
mod time;
mod walk;

use crate::{
    VerifierParams,
    verifier::error::{SdCwtVerifierError, SdCwtVerifierResult},
};
use ::time::OffsetDateTime;
use ciborium::Value;
use cose_key_confirmation::{KeyConfirmation, error::CoseKeyConfirmationError};
use esdicawt_spec::{
    CWT_CLAIM_KEY_CONFIRMATION_MAP, CustomClaims, CwtAny, SdHashAlg, Select,
    blinded_claims::Salted,
    issuance::SdInnerPayload,
    key_binding::KbtCwtTagged,
    reexports::coset::{AsCborValue, CoseSign1, TaggedCborSerializable},
    verified::KbtCwtVerified,
};
use std::collections::HashMap;

pub trait Verifier {
    type Error: core::error::Error + Send + Sync;

    type IssuerSignature;
    type IssuerVerifier: signature::Verifier<Self::IssuerSignature>;

    type HolderSignature;
    type HolderVerifier: signature::Verifier<Self::HolderSignature> + PartialEq + for<'a> TryFrom<&'a KeyConfirmation, Error = CoseKeyConfirmationError>;

    type Hasher: digest::Digest;

    type IssuerProtectedClaims: CustomClaims;
    type IssuerUnprotectedClaims: CustomClaims;
    type IssuerPayloadClaims: Select;
    type KbtUnprotectedClaims: CustomClaims;
    type KbtProtectedClaims: CustomClaims;
    type KbtPayloadClaims: CustomClaims;

    fn deserialize_issuer_signature(&self, bytes: &[u8]) -> Result<Self::IssuerSignature, Self::Error>;
    fn deserialize_holder_signature(&self, bytes: &[u8]) -> Result<Self::HolderSignature, Self::Error>;

    /// Signature public key of the SD-CWT (generated by the Issuer). This key has to be known out-of-band by the Verifier
    /// @Rohan: turn this mandatory ?
    fn issuer_verifying_key(&self) -> Option<&Self::IssuerVerifier>;
    /// Signature public key of the SD-KBT (generated by the Holder). In cases
    fn holder_verifying_key(&self) -> Option<&Self::HolderVerifier>;

    fn digest(&self, sd_alg: SdHashAlg, data: &[u8]) -> Result<Vec<u8>, Self::Error>;

    #[allow(clippy::type_complexity)]
    fn verify_sd_kbt_from_bytes(
        &self,
        kbt_bytes: &[u8],
        params: VerifierParams,
    ) -> Result<
        KbtCwtVerified<
            Self::IssuerPayloadClaims,
            Self::IssuerProtectedClaims,
            Self::IssuerUnprotectedClaims,
            Self::KbtProtectedClaims,
            Self::KbtUnprotectedClaims,
            Self::KbtPayloadClaims,
        >,
        SdCwtVerifierError<Self::Error>,
    > {
        let kbt_tagged = KbtCwtTagged::<
            Self::IssuerPayloadClaims,
            Self::IssuerProtectedClaims,
            Self::IssuerUnprotectedClaims,
            Self::KbtProtectedClaims,
            Self::KbtUnprotectedClaims,
            Self::KbtPayloadClaims,
        >::from_cbor_bytes(kbt_bytes)?;
        self.verify_sd_kbt(&kbt_tagged, params)
    }

    #[allow(clippy::type_complexity)]
    fn verify_sd_kbt(
        &self,
        kbt: &KbtCwtTagged<
            Self::IssuerPayloadClaims,
            Self::IssuerProtectedClaims,
            Self::IssuerUnprotectedClaims,
            Self::KbtProtectedClaims,
            Self::KbtUnprotectedClaims,
            Self::KbtPayloadClaims,
        >,
        params: VerifierParams,
    ) -> Result<
        KbtCwtVerified<
            Self::IssuerPayloadClaims,
            Self::IssuerProtectedClaims,
            Self::IssuerUnprotectedClaims,
            Self::KbtProtectedClaims,
            Self::KbtUnprotectedClaims,
            Self::KbtPayloadClaims,
        >,
        SdCwtVerifierError<Self::Error>,
    > {
        use signature::Verifier as _;

        // TODO: we're gonna mutate the token to serve the ClaimSet so we're lazy here and clone the
        // whole thing. We should at some point only clone the required parts
        let mut kbt = kbt.clone();

        let kbt_value = Value::serialized(&kbt.0)?;
        let kbt_protected = kbt.0.protected.to_value_mut()?;
        let (sd_cwt, sd_cwt_bytes) = kbt_protected.kcwt.to_pair_mut()?;
        let key_confirmation = &sd_cwt.0.payload.to_value()?.cnf;

        let holder_confirmation_key: Self::HolderVerifier = key_confirmation.try_into()?;

        let now = params.current_timestamp.unwrap_or_else(|| OffsetDateTime::now_utc().unix_timestamp());

        // First the Verifier must validate the SD-KBT as described in Section 7.2 of [RFC8392].
        // verifying signature
        let cose_sign1_sd_kbt = CoseSign1::from_cbor_value(kbt_value)?;
        cose_sign1_sd_kbt.verify_signature(&[], |signature, raw_data| {
            let signature = self.deserialize_holder_signature(signature).map_err(SdCwtVerifierError::CustomError)?;
            holder_confirmation_key.verify(raw_data, &signature).map_err(SdCwtVerifierError::from)
        })?;

        // verify confirmation key advertised in the KBT matches the expected one if supplied
        if let Some(hvk) = self.holder_verifying_key() {
            let key_confirmation: Self::HolderVerifier = key_confirmation.try_into()?;
            if key_confirmation != *hvk {
                return Err(SdCwtVerifierError::UnexpectedKeyConfirmation);
            }
        }

        // verify time claims
        let kbt_payload = kbt.0.payload.to_value()?;
        time::verify_time_claims(now, params.leeway, Some(kbt_payload.issued_at), kbt_payload.expiration, kbt_payload.not_before)?;

        // TODO: verify revocation status w/ Status List

        // After validation, the SD-CWT MUST be extracted from the kcwt header, and validated as described in Section 7.2 of [RFC8392].
        // verify signature if a verifying key supplied
        if let Some(issuer_verifying_key) = self.issuer_verifying_key() {
            let cose_sign1_sd_cwt = CoseSign1::from_tagged_slice(sd_cwt_bytes)?;
            cose_sign1_sd_cwt.verify_signature(&[], |signature, raw_data| {
                let signature = self.deserialize_issuer_signature(signature).map_err(SdCwtVerifierError::CustomError)?;
                issuer_verifying_key.verify(raw_data, &signature).map_err(SdCwtVerifierError::from)
            })?;
        }

        let sd_cwt_payload = sd_cwt.0.payload.to_value_mut()?;

        // verify time claims
        time::verify_time_claims(
            now,
            params.leeway,
            sd_cwt_payload.inner.issued_at,
            sd_cwt_payload.inner.expiration,
            sd_cwt_payload.inner.not_before,
        )?;

        // TODO: verify revocation status w/ Status List

        // now verifying the disclosures
        let disclosures = &mut sd_cwt.0.sd_unprotected.sd_claims;
        let disclosures_size = disclosures.len();

        let sd_alg = sd_cwt.0.protected.to_value()?.sd_alg;

        // compute the hash of all disclosures
        let mut disclosures = disclosures
            .iter_mut()
            .map(|d| match d {
                Ok(salted) => {
                    let bytes = salted.to_cbor_bytes()?;
                    let digest = self.digest(sd_alg, &bytes[..]).map_err(SdCwtVerifierError::CustomError)?;
                    SdCwtVerifierResult::Ok((digest, salted))
                }
                Err(e) => Err(e.into()),
            })
            .collect::<Result<HashMap<Vec<u8>, &mut Salted<Value>>, _>>()?;

        if disclosures.len() != disclosures_size {
            return Err(SdCwtVerifierError::DisclosureHashCollision);
        }

        let mut payload = Value::serialized(&sd_cwt_payload)?;
        walk::walk_payload(&mut payload, &mut disclosures)?;

        if let Some(map) = payload.as_map_mut() {
            map.retain(|(k, _)| !matches!(k, Value::Integer(i) if i == &CWT_CLAIM_KEY_CONFIRMATION_MAP.into()));
        }

        // TODO: this might fail if `Self::DisclosedClaims` does not support unknown claims (serde flatten etc..)
        let sd_cwt_payload = payload.deserialized::<SdInnerPayload<Self::IssuerPayloadClaims>>()?;
        let claimset = sd_cwt_payload
            .extra
            .ok_or(SdCwtVerifierError::MalformedSdCwt("Could not find disclosed claims in verified payload"))?;

        Ok(KbtCwtVerified {
            protected: kbt_protected.clone().try_into()?,
            unprotected: kbt.0.unprotected,
            payload: kbt.0.payload.try_into_value()?,
            claimset,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::claims::CustomTokenClaims;
    use crate::{
        HolderParams, Issuer, IssuerParams, Presentation, Verifier, VerifierParams,
        holder::Holder,
        spec::EsdicawtSpecError,
        test_utils::{Ed25519Holder, P256IssuerClaims},
        verifier::test_utils::HybridVerifier,
    };
    use ciborium::{Value, cbor};
    use esdicawt_spec::{CwtAny, NoClaims, Select, key_binding::KbtCwtTagged, verified::KbtCwtVerified};
    use rand_core::SeedableRng as _;

    wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);

    #[test]
    #[wasm_bindgen_test::wasm_bindgen_test]
    fn should_verify_valid_sd_cwt() {
        let payload = CustomTokenClaims { name: Some("Alice Smith".into()) };
        let verified = verify(payload);

        assert_eq!(verified.claimset.name.as_deref(), Some("Alice Smith"));
        assert_eq!(verified.sd_cwt().payload.subject, Some("mimi://example.com/u/alice.smith".into()));
    }

    #[test]
    #[wasm_bindgen_test::wasm_bindgen_test]
    fn should_verify_complex() {
        let verifying = |value: Result<Value, ciborium::value::Error>| {
            let value = value.unwrap();
            let payload = cbor!({ "___claim" => value }).unwrap();
            let verified = verify(payload);

            let claimset = verified.claimset.into_map().unwrap();
            let (_, claim) = claimset.iter().find(|(k, _)| matches!(k, Value::Text(t) if t == "___claim")).unwrap();
            assert_eq!(claim, &value);
        };

        // simple string
        verifying(cbor!("a"));

        // nested mapping
        verifying(cbor!({ "a" => "b" }));

        // simple array
        verifying(cbor!([0, 1]));

        // nested array
        verifying(cbor!([[0, 1]]));

        // mapping in array
        verifying(cbor!([{ "a" => "b"} ]));

        // array in mapping
        verifying(cbor!({ "a" => [0, 1] }));
    }

    fn verify<T: Select<Error = EsdicawtSpecError>>(payload: T) -> KbtCwtVerified<T> {
        let (issuer_signing_key, holder_signing_key, sd_kbt) = generate(payload);
        let verifier = HybridVerifier::<T> {
            issuer_verifying_key: *issuer_signing_key.verifying_key(),
            holder_verifying_key: holder_signing_key.verifying_key(),
            _marker: Default::default(),
        };
        let verifier_params = VerifierParams {
            current_timestamp: None,
            leeway: 0,
        };
        verifier.verify_sd_kbt(&sd_kbt, verifier_params).unwrap()
    }

    #[allow(clippy::type_complexity)]
    fn generate<T: Select<Error = EsdicawtSpecError>>(payload: T) -> (p256::ecdsa::SigningKey, ed25519_dalek::SigningKey, KbtCwtTagged<T>) {
        let mut csprng = rand_chacha::ChaCha20Rng::from_entropy();

        let issuer_signing_key = p256::ecdsa::SigningKey::random(&mut csprng);
        let holder_signing_key = ed25519_dalek::SigningKey::generate(&mut csprng);

        let issuer = P256IssuerClaims::new(issuer_signing_key.clone());

        let issue_params = IssuerParams {
            protected_claims: None,
            unprotected_claims: None,
            payload: Some(payload),
            subject: "mimi://example.com/u/alice.smith",
            issuer: "mimi://example.com/i/acme.io",
            expiry: core::time::Duration::from_secs(90),
            leeway: core::time::Duration::from_secs(1),
            key_location: "https://auth.acme.io/issuer.cwk",
            holder_confirmation_key: (&holder_signing_key.verifying_key()).try_into().unwrap(),
        };
        let sd_cwt = issuer.issue_cwt(&mut csprng, issue_params).unwrap().to_cbor_bytes().unwrap();

        let holder = Ed25519Holder::new(holder_signing_key.clone());
        let presentation_params = HolderParams {
            presentation: Presentation::Full,
            audience: "mimi://example.com/r/alice-bob-group",
            expiry: core::time::Duration::from_secs(90 * 24 * 3600),
            leeway: core::time::Duration::from_secs(3600),
            extra_kbt_unprotected: None,
            extra_kbt_protected: None,
            extra_kbt_payload: None,
        };

        let sd_kbt = holder.new_presentation(&sd_cwt, presentation_params).unwrap();
        (issuer_signing_key, holder_signing_key, sd_kbt)
    }

    #[allow(dead_code, unused_variables, clippy::type_complexity)]
    fn should_be_object_safe(
        holder: Box<
            dyn Verifier<
                    IssuerProtectedClaims = NoClaims,
                    IssuerPayloadClaims = NoClaims,
                    IssuerUnprotectedClaims = NoClaims,
                    KbtProtectedClaims = NoClaims,
                    KbtUnprotectedClaims = NoClaims,
                    KbtPayloadClaims = NoClaims,
                    Error = std::convert::Infallible,
                    Hasher = sha2::Sha256,
                    HolderSignature = ed25519_dalek::Signature,
                    HolderVerifier = ed25519_dalek::VerifyingKey,
                    IssuerSignature = p256::ecdsa::Signature,
                    IssuerVerifier = p256::ecdsa::VerifyingKey,
                >,
        >,
    ) {
    }
}

#[cfg(test)]
pub mod claims {
    use ciborium::Value;
    use esdicawt_spec::{EsdicawtSpecError, Select, SelectiveDisclosure, sd};

    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
    pub(super) struct CustomTokenClaims {
        pub name: Option<String>,
    }

    impl Select for CustomTokenClaims {
        type Error = EsdicawtSpecError;

        fn select(self) -> Result<SelectiveDisclosure, <Self as Select>::Error> {
            let mut map = Vec::with_capacity(1);
            if let Some(name) = self.name {
                map.push((sd(Value::Text("name".into())), Value::Text(name)));
            }
            Ok(Value::Map(map).into())
        }
    }
}

#[cfg(feature = "test-utils")]
pub mod test_utils {
    use super::*;
    use esdicawt_spec::NoClaims;

    pub struct HybridVerifier<DisclosedClaims: CustomClaims> {
        pub issuer_verifying_key: p256::ecdsa::VerifyingKey,
        pub holder_verifying_key: ed25519_dalek::VerifyingKey,
        pub _marker: core::marker::PhantomData<DisclosedClaims>,
    }

    impl<T: Select> Verifier for HybridVerifier<T> {
        type Error = std::convert::Infallible;
        type IssuerSignature = p256::ecdsa::Signature;
        type IssuerVerifier = p256::ecdsa::VerifyingKey;
        type HolderSignature = ed25519_dalek::Signature;
        type HolderVerifier = ed25519_dalek::VerifyingKey;
        type Hasher = sha2::Sha256;
        type IssuerProtectedClaims = NoClaims;
        type IssuerUnprotectedClaims = NoClaims;
        type IssuerPayloadClaims = T;
        type KbtUnprotectedClaims = NoClaims;
        type KbtProtectedClaims = NoClaims;
        type KbtPayloadClaims = NoClaims;

        fn deserialize_issuer_signature(&self, bytes: &[u8]) -> Result<Self::IssuerSignature, Self::Error> {
            Ok(p256::ecdsa::Signature::try_from(bytes).unwrap())
        }

        fn deserialize_holder_signature(&self, bytes: &[u8]) -> Result<Self::HolderSignature, Self::Error> {
            Ok(ed25519_dalek::Signature::try_from(bytes).unwrap())
        }

        fn issuer_verifying_key(&self) -> Option<&Self::IssuerVerifier> {
            Some(&self.issuer_verifying_key)
        }

        fn holder_verifying_key(&self) -> Option<&Self::HolderVerifier> {
            Some(&self.holder_verifying_key)
        }

        fn digest(&self, sd_alg: SdHashAlg, data: &[u8]) -> Result<Vec<u8>, Self::Error> {
            use digest::Digest as _;
            Ok(match sd_alg {
                SdHashAlg::Sha256 => sha2::Sha256::digest(data).to_vec(),
                _ => unreachable!(),
            })
        }
    }
}
